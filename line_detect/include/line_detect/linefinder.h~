#if !defined LINEF
#define LINEF

#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <math.h>
#include "line_detect/points.h"
#define PI 3.1415926
using namespace std;
using namespace cv;

class LineFinder {
  private:
	  // original image
	  cv::Mat img;
	  // vector containing the end points
	  
	  // accumulator resolution parameters
	  double deltaRho;
	  double deltaTheta;
	  // minimum number of votes that a line
	  // must receive before being considered
	  int minVote;
	  // min length for a line
	  double minLength;
	  // max allowed gap along the line
	  double maxGap;
	  double thre_DistanceOfLines;
	  double thre_angel;
  public:
	// of the detected lines
	  std::vector<cv::Vec4i> lines;
	  // Default accumulator resolution is 1 pixel by 1 degree
	  // no gap, no mimimum length
	  LineFinder() : deltaRho(1), deltaTheta(PI/180), minVote(10), minLength(0.), maxGap(0.) {}
	  // Set the resolution of the accumulator
	  void setAccResolution(double dRho, double dTheta) {
		  deltaRho= dRho;
		  deltaTheta= dTheta;
	  }
	  // Set the minimum number of votes
	  void setMinVote(int minv) {
		  minVote= minv;
	  }
	  // Set line length and gap
	  void setLineLengthAndGap(double length, double gap) {
		  minLength= length;
		  maxGap= gap;
	  }
	  void setThre_DistanceOfLines(double thre_DistanceOfLines_)
	  {
	      thre_DistanceOfLines = thre_DistanceOfLines_;
	  }
	  void setThre_angel(double thre_angel_)
	  {
	      thre_angel = thre_angel_;
	  }
	  // Apply probabilistic Hough Transform
	  std::vector<cv::Vec4i> findLines(cv::Mat& binary) {
		  lines.clear();
		  cv::HoughLinesP(binary,lines,deltaRho,deltaTheta,minVote, minLength, maxGap);
		  return lines;
	  }
	  // Draw the detected lines on an image
        void drawDetectedLines(cv::Mat &image, cv::Scalar color=cv::Scalar(255,0,0)) {
		  // Draw the lines
		  std::vector<cv::Vec4i>::const_iterator it2= lines.begin();
		  while (it2!=lines.end())
            {
			  cv::Point pt1((*it2)[0],(*it2)[1]);
			  cv::Point pt2((*it2)[2],(*it2)[3]);
			  cv::line( image, pt1, pt2, color,2);
			  ++it2;
		  }
	  }
	  void selectGoodLines()
	  {
        vector<Vec4i> goodAngel,goodLines;
		vector<int> repeatedIndex;
		for(int i=0;i!=lines.size();i++)
		{
			double x0 = lines[i][0];
			double y0 = lines[i][1];
            double x1 = lines[i][2];
            double y1 = lines[i][3];
			double ki;
			ki = (y1-y0)/(x1-x0);
			if(abs(ki)<tan(PI*thre_angel/180))
			{
				goodAngel.push_back(lines[i]);
			}
		}

		for(int i=0;i!=goodAngel.size();i++)
		{
			double x0 = goodAngel[i][0];
			double y0 = goodAngel[i][1];
		        double x1 = goodAngel[i][2];
		        double y1 = goodAngel[i][3];
			double ki,bi;
			ki = (y1-y0)/(x1-x0);
			bi = y0 - ki*x0;
			for(int j=i+1;j!=goodAngel.size();j++)
			{
				double xj0 = goodAngel[j][0];
				double yj0 = goodAngel[j][1];
				double xj1 = goodAngel[j][2];
				double yj1 = goodAngel[j][3];
				double kj,bj;
				kj = (yj1-yj0)/(xj1-xj0);
				bj = yj0 - kj*xj0;
				if(sqrt((kj-ki)*(kj-ki)+(bj-bi)*(bj-bi)) < thre_DistanceOfLines)
				{
					repeatedIndex.push_back(j);
				}
				//cout<<sqrt((kj-ki)*(kj-ki)+(bj-bi)*(bj-bi))<<endl;
			}
		}
		for(int i=0;i!=goodAngel.size();i++)
		{
			bool flag = true;
			for(int j=0;j!=repeatedIndex.size();j++)
			{
				if(i==repeatedIndex[j])flag = false;
			}
			if(flag)goodLines.push_back(goodAngel[i]);
		}
		lines.clear();
		lines.insert(lines.begin(),goodLines.begin(),goodLines.end());
		cout<<"lines.size(): "<<lines.size()<<" thre_angel: "<<thre_angel<<" thre_distance: "<<thre_DistanceOfLines<<endl;
	  }

	  // Eliminates lines that do not have an orientation equals to
	  // the ones specified in the input matrix of orientations
	  // At least the given percentage of pixels on the line must
	  // be within plus or minus delta of the corresponding orientation
	  std::vector<cv::Vec4i> removeLinesOfInconsistentOrientations(
		  const cv::Mat &orientations, double percentage, double delta) {
			  std::vector<cv::Vec4i>::iterator it= lines.begin();
			  // check all lines
			  while (it!=lines.end()) {
				  // end points
				  int x1= (*it)[0];
				  int y1= (*it)[1];
				  int x2= (*it)[2];
				  int y2= (*it)[3];
				  // line orientation + 90o to get the parallel line
				  double ori1= atan2(static_cast<double>(y1-y2),static_cast<double>(x1-x2))+PI/2;
				  if (ori1>PI) ori1= ori1-2*PI;
				  double ori2= atan2(static_cast<double>(y2-y1),static_cast<double>(x2-x1))+PI/2;
				  if (ori2>PI) ori2= ori2-2*PI;
				  // for all points on the line
				  cv::LineIterator lit(orientations,cv::Point(x1,y1),cv::Point(x2,y2));
				  int i,count=0;
				  for(i = 0, count=0; i < lit.count; i++, ++lit) {
					  float ori= *(reinterpret_cast<float *>(*lit));
					  // is line orientation similar to gradient orientation ?
					  if (std::min(fabs(ori-ori1),fabs(ori-ori2))<delta)
						  count++;
				  }

				  double consistency= count/static_cast<double>(i);

				  // set to zero lines of inconsistent orientation
				  if (consistency < percentage) {
					  (*it)[0]=(*it)[1]=(*it)[2]=(*it)[3]=0;
				  }
				  ++it;
			  }

			  return lines;
	  }
};


#endif
